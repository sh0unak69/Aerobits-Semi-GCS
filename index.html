<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GCS Telemetry Dashboard</title>
    <!-- Tailwind CSS for styling --><script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js for graphing --><script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- JSZip to handle zip files --><script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- PapaParse to parse CSV files --><script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        /* Custom styles to ensure a no-scroll, full-height layout */
        body, html {
            height: 100%;
            margin: 0;
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrolling */
            background-color: #111827; /* Dark background */
        }
        /* Flexbox layout for main container */
        .main-container {
            display: flex;
            height: 100vh;
            padding: 1rem;
            gap: 1rem;
        }
        /* Left and right panel styling */
        .left-panel {
            width: 40%; /* 40% of the screen */
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .right-panel {
            width: 60%; /* 60% of the screen */
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        /* Video container styling */
        .video-container {
            /* flex-grow: 1; Takes up most space - Removed flex-grow to allow aspect ratio */
            background-color: #1f2937;
            border-radius: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #9ca3af;
            overflow: hidden; /* Ensures video fits within rounded corners */
            min-height: 0; /* Prevents flexbox overflow */
            position: relative; /* Needed for absolute positioning of button */
            width: 100%; /* Take full width of parent */
            aspect-ratio: 4 / 3; /* Enforce 4:3 aspect ratio */
        }
        .video-container video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Show entire video, potentially with black bars */
            display: block; /* Remove extra space below video */
        }
         /* Fullscreen button styling */
        #fullscreen-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 0.25rem;
            padding: 0.25rem;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
            display: none; /* Hidden by default */
        }
        #fullscreen-btn:hover {
            opacity: 1;
        }
        #fullscreen-btn svg {
            width: 1rem; /* Adjust size as needed */
            height: 1rem;
            display: block;
        }
        /* Tilt container styling */
        .tilt-container {
             /* height: 150px; Give the tilt animation a fixed height - Removed */
             flex-grow: 1; /* Allow it to fill remaining space */
             min-height: 0; /* Prevent overflow */
             /* flex-shrink: 0; - Removed as flex-grow handles this */
             background-color: #1f2937;
             border-radius: 0.5rem;
             display: flex;
             flex-direction: column;
             justify-content: center;
             align-items: center;
             padding: 0.5rem;
             position: relative; /* Added for positioning readouts */
        }
        /* Grid for charts */
        .charts-grid {
            flex-grow: 1;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(2, 1fr); /* 2 rows needed for 8 items */
            gap: 1rem;
            min-height: 0; /* CRITICAL FIX: Prevents grid from expanding beyond its flex container */
        }
        /* Individual chart container styling */
        .chart-wrapper {
            background-color: #1f2937;
            border-radius: 0.5rem;
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevents content from stretching the grid cell */
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
         .chart-wrapper:hover {
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.3);
        }
        /* Ensure canvas fills the container */
        .chart-wrapper canvas {
            flex-grow: 1;
            min-height: 0;
        }
        .video-container span {
            font-size: 0.8rem;
        }
        .chart-controls {
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            padding-top: 0.5rem;
        }
        .chart-toggle-btn {
            background-color: #374151;
            color: #d1d5db;
            border: 1px solid #4b5563;
            padding: 0.15rem 0.6rem;
            font-size: 0.6rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s, opacity 0.2s, filter 0.2s;
        }
        .chart-toggle-btn:hover {
            filter: brightness(85%);
        }
        .chart-toggle-btn.inactive {
            opacity: 0.6;
        }
        #tilt-indicator {
            transition: transform 1s linear;
        }
         /* Style for Live Mode Button */
        #live-mode-btn.live-on {
            background-color: #dc2626; /* Red when live */
            hover:bg-red-700;
        }
    </style>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
</head>
<body>
    <!-- Drag and Drop Overlay --><div id="drag-drop-overlay" class="hidden fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center pointer-events-none z-50 transition-opacity duration-300">
        <div id="overlay-text" class="text-white text-xl font-bold border-4 border-dashed border-white rounded-lg p-12 text-center">
            Drop ZIP or CSV File Anywhere
        </div>
    </div>
    
    <!-- Chart Modal --><div id="chart-modal" class="hidden fixed inset-0 bg-black bg-opacity-85 flex justify-center items-center z-50 p-8 cursor-pointer">
        <div class="bg-gray-800 rounded-lg p-4 w-full h-full max-w-6xl max-h-4xl relative cursor-default flex flex-col gap-2">
            <!-- Modal Header --><div class="flex justify-between items-center flex-shrink-0">
                <h2 id="modal-title" class="text-lg font-bold text-white">Chart Title</h2>
                 <button id="modal-close-btn" class="text-white text-3xl font-bold hover:text-gray-400 transition-colors">&times;</button>
            </div>
            <!-- Modal Body --><div class="w-full h-full flex-grow min-h-0">
                <canvas id="modal-canvas"></canvas>
            </div>
        </div>
    </div>

    <!-- Main container for the entire layout --><div class="main-container">
        <!-- Left panel for video and tilt animation --><div class="left-panel">
            <div class="video-container" id="video-up-container">
                <span>Video Player</span> <!-- Changed placeholder text -->
                 <!-- Fullscreen Button added here -->
                <button id="fullscreen-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
                    </svg>                      
                </button>
            </div>
             <!-- Tilt Animation moved here -->
            <div class="tilt-container">
                 <!-- Angle Readouts -->
                 <div class="absolute top-2 right-2 text-right text-xs text-gray-400">
                    <p id="roll-readout">Roll: 0.00°</p>
                    <p id="pitch-readout">Pitch: 0.00°</p>
                </div>
                <!-- Tilt Bar -->
                 <div class="w-4 h-4/5 bg-blue-500 rounded" id="tilt-indicator"></div>
            </div>
        </div>

        <!-- Right panel for header, charts, and footer --><div class="right-panel">
            <header class="text-center py-4 bg-gray-800 rounded-lg flex-shrink-0">
                <h1 class="text-2xl font-bold text-white">TEAM MASSS</h1>
            </header>
            <div class="charts-grid">
                <!-- Row 1: Altitude, Pressure, Velocity, Temp -->
                <div class="chart-wrapper"><canvas id="altitude-chart"></canvas></div>
                <div class="chart-wrapper"><canvas id="pressure-chart"></canvas></div>
                <div class="chart-wrapper"><canvas id="velocity-chart"></canvas></div>
                <div class="chart-wrapper"><canvas id="temp-chart"></canvas></div>
                
                <!-- Row 2: Gyro, Accel, Auto Rotation, Voltage -->
                <div class="chart-wrapper">
                    <canvas id="gyro-chart"></canvas>
                    <div class="chart-controls">
                        <button class="chart-toggle-btn" data-chart="gyro" data-dataset="0">Roll</button>
                        <button class="chart-toggle-btn" data-chart="gyro" data-dataset="1">Pitch</button>
                        <button class="chart-toggle-btn" data-chart="gyro" data-dataset="2">Yaw</button>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="accel-chart"></canvas>
                    <div class="chart-controls">
                        <button class="chart-toggle-btn" data-chart="accel" data-dataset="0">AccX</button> <!-- Changed Label -->
                        <button class="chart-toggle-btn" data-chart="accel" data-dataset="1">AccY</button> <!-- Changed Label -->
                        <button class="chart-toggle-btn" data-chart="accel" data-dataset="2">AccZ</button> <!-- Changed Label -->
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="rotation-chart"></canvas>
                    <div class="chart-controls">
                        <button class="chart-toggle-btn" data-chart="rotation" data-dataset="0">AutoGyro1</button>
                        <button class="chart-toggle-btn" data-chart="rotation" data-dataset="1">AutoGyro2</button>
                    </div>
                </div>
                 <div class="chart-wrapper"><canvas id="voltage-chart"></canvas></div>
            </div>
            <!-- Footer for controls, styled like the header --><footer class="bg-gray-800 rounded-lg flex-shrink-0 p-2 flex flex-col gap-2">
                 <!-- Row 1: File Operations & Mode --><div class="flex justify-center items-center gap-4 w-full">
                    <button id="upload-btn" class="text-xs flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-lg transition duration-300 text-center">
                        Upload ZIP File
                    </button>
                    <input type="file" id="zip-input" class="hidden" accept=".zip">

                    <button id="upload-csv-btn" class="text-xs flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-lg transition duration-300 text-center">
                        Upload CSV File
                    </button>
                    <input type="file" id="csv-input" class="hidden" accept=".csv">

                    <button id="download-csv-btn" class="text-xs flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-lg transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed text-center" disabled>
                        Download CSV
                    </button>
                     <button id="data-mode-btn" class="text-xs flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-3 rounded-lg transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed text-center" disabled>
                        Mode: Filtered
                    </button>
                </div>
                <!-- Row 2: Playback Controls --><div class="flex justify-center items-center gap-4 w-full">
                    <button id="rewind-btn" class="text-xs flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-3 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed" disabled>-5s</button>
                    <button id="forward-btn" class="text-xs flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-3 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed" disabled>+5s</button>
                    <button id="play-pause-btn" class="text-xs flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-3 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed" disabled>Play</button>
                    <button id="speed-btn" class="text-xs flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-3 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed" disabled>1x</button>
                    <button id="end-btn" class="text-xs flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-3 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed" disabled>End</button>
                    <button id="crop-btn" class="text-xs flex-1 bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-1 px-3 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed" disabled>Crop</button> <!-- Added Crop button -->
                </div>
                <!-- Row 3: Additional Controls (Blink, Live) --><div class="flex justify-center items-center gap-4 w-full">
                    <button id="blink-btn" class="text-xs flex-1 bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-3 rounded-lg transition">Blink</button>
                    <button id="live-mode-btn" class="text-xs flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded-lg transition">Live : Off</button> <!-- New Live Button -->
                </div>
            </footer>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // File and general UI elements
            const uploadButton = document.getElementById('upload-btn');
            const zipInput = document.getElementById('zip-input');
            const uploadCsvButton = document.getElementById('upload-csv-btn');
            const csvInput = document.getElementById('csv-input');
            const downloadCsvButton = document.getElementById('download-csv-btn');
            const dataModeButton = document.getElementById('data-mode-btn');
            const overlay = document.getElementById('drag-drop-overlay');
            const overlayText = document.getElementById('overlay-text');
            const videoUpContainer = document.getElementById('video-up-container');
            const tiltIndicator = document.getElementById('tilt-indicator');
            const fullscreenBtn = document.getElementById('fullscreen-btn'); // Get fullscreen button
            const rollReadout = document.getElementById('roll-readout'); // Get readout element
            const pitchReadout = document.getElementById('pitch-readout'); // Get readout element
            
            // Playback control buttons
            const rewindBtn = document.getElementById('rewind-btn');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const forwardBtn = document.getElementById('forward-btn');
            const speedBtn = document.getElementById('speed-btn');
            const endBtn = document.getElementById('end-btn');
            const cropBtn = document.getElementById('crop-btn'); // Get Crop button

            // Live buttons
            const blinkBtn = document.getElementById('blink-btn'); 
            const liveModeBtn = document.getElementById('live-mode-btn'); // Get Live Mode button

            // Modal elements
            const chartModal = document.getElementById('chart-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalCloseBtn = document.getElementById('modal-close-btn');
            const modalCanvasCtx = document.getElementById('modal-canvas').getContext('2d');
            let modalChartInstance = null;

            // State variables
            let charts = {};
            let plotInterval = null;
            let telemetryData = []; // Holds raw data with derived values
            let filteredTelemetryData = []; // Holds filtered data
            let currentIndex = 0; // Current index relative to the cropPoint
            let cropPoint = 0; // The original index where the last crop occurred
            let P0 = null; // Pressure at sea level (or first reading)
            let isPaused = true;
            let playbackSpeed = 1;
            let dataDisplayMode = 'filtered'; // 'filtered', 'raw', 'compare'
            let isLiveMode = false; // Live Telemetry: Flag for live mode
            let liveDataCounter = 0; // Live Telemetry: Counter for live data points
            let lastFilteredValues = {}; // Live Telemetry: Store last filtered values for EMA continuity
            let lastRawAltitude = 0; // Live Telemetry: Store last raw altitude for velocity calculation
            
            // --- Kalman Filter Implementation ---
            /**
             * Creates a 1D Kalman Filter object.
             * @param {number} Q_std_dev - Standard deviation of the process noise (gyro rate std dev).
             * @param {number} R_std_dev - Standard deviation of the measurement noise (accelerometer angle std dev).
             */
            function KalmanFilter1D(Q_std_dev, R_std_dev) {
                // Tunable parameters based on user's math
                this.Ts = 1.0; // Time step (1s)
                this.Q_variance = Math.pow(Q_std_dev, 2); // Process noise variance (4^2 = 16)
                this.R_variance = Math.pow(R_std_dev, 2); // Measurement noise variance (3^2 = 9)

                // State variables
                this.phi = 0; // This is the estimated angle (phi)
                this.P = 1;   // Initial uncertainty (P) - start with 1
                
                /**
                 * Resets the filter to its initial state.
                 */
                this.reset = function() {
                    this.phi = 0;
                    this.P = 1;
                };

                /**
                 * Updates the filter with new measurements.
                 * @param {number} gyroRate - The angular velocity (w[k]) from the gyro.
                 * @param {number} accelAngle - The angle (theta[k]) calculated from the accelerometer.
                 * @returns {number} The new filtered angle (phi[k]).
                 */
                this.update = function(gyroRate, accelAngle) {
                    // --- 1. Prediction Step ---
                    
                    // phi[k] = phi[k-1] + 1*w[k]
                    // (Predict new angle based on old angle and gyro rate)
                    let phi_predicted = this.phi + this.Ts * gyroRate;
                    
                    // P[k] = P[k-1] + (1^2)*(4^2)
                    // (Predict new uncertainty: P_old + process_noise)
                    let P_predicted = this.P + (this.Ts * this.Ts) * this.Q_variance;

                    // --- 2. Update Step ---

                    // L[k] = P[k] + (1^2)*(3^2) - (This is the denominator for K_gain)
                    // K_gain = P[k]/(P[k] + (1^2)*(3^2))
                    // (Calculate Kalman Gain)
                    let K_gain = P_predicted / (P_predicted + this.R_variance);

                    // phi[k] = phi[k] + K_gain(theta[k] - phi[k])
                    // (Update angle estimate with accelerometer reading)
                    // This is phi_new = phi_predicted + K * (accel_angle - phi_predicted)
                    let phi_updated = phi_predicted + K_gain * (accelAngle - phi_predicted);

                    // P[k] = (1-K_gain)*P[k]
                    // (Update the uncertainty)
                    let P_updated = (1 - K_gain) * P_predicted;

                    // Store the new state for the next iteration
                    this.phi = phi_updated;
                    this.P = P_updated;

                    // Return the new filtered angle
                    return this.phi;
                };
            }

            // Create global instances for Roll and Pitch filters
            let kalmanRoll = new KalmanFilter1D(4, 3);
            let kalmanPitch = new KalmanFilter1D(4, 3);
            // --- End of Kalman Filter ---

            // EMA Filter function
            const alpha = 0.2;
            function emaFilter(data) {
                if (!data || data.length === 0) return [];
                const firstVal = typeof data[0] === 'number' ? data[0] : 0;
                const filtered = [firstVal];
                for (let i = 1; i < data.length; i++) {
                    const prevFiltered = filtered[i - 1];
                    let currentRaw = data[i];
                    if (typeof currentRaw !== 'number' || currentRaw === null) currentRaw = prevFiltered;
                    filtered.push(alpha * currentRaw + (1 - alpha) * prevFiltered);
                }
                return filtered;
            }
             // Live Telemetry: EMA Filter for a single point
            function emaFilterSinglePoint(key, newValue) {
                if(typeof newValue !== 'number' || newValue === null) {
                    newValue = lastFilteredValues[key] || 0; // Use last good value if current is bad
                }
                const prevFiltered = lastFilteredValues[key] || newValue; // Use newValue if it's the first point
                const filteredValue = alpha * newValue + (1 - alpha) * prevFiltered;
                lastFilteredValues[key] = filteredValue; // Update last value
                return filteredValue;
            }

            // Simple velocity calculation from altitude
            function velocityCalculator(altitudeData) {
                if (!altitudeData || altitudeData.length === 0) return [];
                const velocities = [0]; // Start with 0 for the first point
                for (let i = 1; i < altitudeData.length; i++) {
                    const velocity = altitudeData[i] - altitudeData[i - 1];
                    velocities.push(velocity);
                }
                return velocities;
            }
             // Live Telemetry: Calculate single velocity point
            // let lastRawAltitude = 0; // Moved to state variables
            function calculateSingleVelocity(newRawAltitude) {
                const velocity = newRawAltitude - lastRawAltitude;
                lastRawAltitude = newRawAltitude; // Update last altitude
                return velocity;
            }
            
            // Helper to calculate accelerometer angles
            function getAccelAngles(ax, ay, az) {
                // Sanitize inputs for this function specifically
                ax = Number(ax) || 0;
                ay = Number(ay) || 0;
                az = Number(az) || 0;
                const theta_roll = Math.atan2(ay, az) * (180 / Math.PI);
                const theta_pitch = Math.atan2(-ax, Math.sqrt(ay * ay + az * az)) * (180 / Math.PI);
                return { theta_roll, theta_pitch };
            }

            // Refactored data processing function
            function processAndFilterData(rawCsvData, P0) { // Accept P0
                if (!rawCsvData || rawCsvData.length === 0) return { raw: [], filtered: [] };
                // const P0 = 1013.25; // Removed global constant

                // == STEP 1: Create the RAW dataset with derived values ==
                const rawDerivedData = [];
                const rawAltitudes = [];
                for (let i = 0; i < rawCsvData.length; i++) {
                    const newRow = { ...rawCsvData[i] };
                    
                    // --- SANITIZATION ---
                    // Ensure all critical values are numbers, default to 0 if not.
                    newRow['Pressure'] = Number(newRow['Pressure']) || 0;
                    newRow['AccX'] = Number(newRow['AccX']) || 0;
                    newRow['AccY'] = Number(newRow['AccY']) || 0;
                    newRow['AccZ'] = Number(newRow['AccZ']) || 0;
                    newRow['Gyro Roll'] = Number(newRow['Gyro Roll']) || 0;
                    newRow['Gyro Pitch'] = Number(newRow['Gyro Pitch']) || 0;
                    newRow['Gyro Yaw'] = Number(newRow['Gyro Yaw']) || 0;
                    newRow['Temperature'] = Number(newRow['Temperature']) || 0;
                    newRow['Voltage'] = Number(newRow['Voltage']) || 0;
                    newRow['Auto Rotation 1'] = Number(newRow['Auto Rotation 1']) || 0;
                    newRow['Auto Rotation 2'] = Number(newRow['Auto Rotation 2']) || 0;
                    // --- END SANITIZATION ---

                    const pressure = newRow['Pressure'];
                     // Convert pressure from Pa to hPa if necessary, assuming CSV is in Pa
                    const pressureHpa = pressure / 100.0; // CSV pressure is in Pa
                    newRow['Altitude'] = (pressureHpa === null || pressureHpa <= 0) ? 0 : 44330 * (1 - Math.pow(pressureHpa / P0, 1 / 5.255));
                    
                    // Calculate accel angles and add them to raw data row
                    const { theta_roll, theta_pitch } = getAccelAngles(newRow['AccX'], newRow['AccY'], newRow['AccZ']);
                    newRow['theta_roll'] = theta_roll;
                    newRow['theta_pitch'] = theta_pitch;

                    rawAltitudes.push(newRow['Altitude']);
                    rawDerivedData.push(newRow); // Store original Pa pressure
                }
                
                const rawVelocities = velocityCalculator(rawAltitudes);
                rawDerivedData.forEach((row, i) => row['Velocity'] = rawVelocities[i]);
                

                // == STEP 2: Create the FILTERED dataset ==
                // Reset Kalman filters before processing a new file
                kalmanRoll.reset();
                kalmanPitch.reset();

                // Columns for EMA filter (ALL gyro rates are now filtered)
                const columnsToFilter = {
                    'Pressure': [], 'Altitude': [], 'Velocity': [], 'Temperature': [], 'Voltage': [], 
                    'Gyro Roll': [], 'Gyro Pitch': [], 'Gyro Yaw': [], // ADDED Gyro Roll/Pitch for EMA
                    'AccX': [], 'AccY': [], 'AccZ': [], 
                    'Auto Rotation 1': [], 'Auto Rotation 2': []
                };
                rawDerivedData.forEach(row => {
                    for (const key in columnsToFilter) {
                        columnsToFilter[key].push(row[key]); 
                    }
                });
                
                const filteredColumns = {};
                for (const key in columnsToFilter) {
                    filteredColumns[key] = emaFilter(columnsToFilter[key]);
                }
                
                const filteredDerivedData = [];
                for (let i = 0; i < rawDerivedData.length; i++) {
                    const filteredRow = {};
                    // Copy all EMA-filtered values
                    for (const key in filteredColumns) {
                        filteredRow[key] = filteredColumns[key][i];
                    }
                    
                    // Now, run Kalman filter for Roll and Pitch (but don't plot them)
                    const rawRow = rawDerivedData[i];
                    const theta_roll = rawRow['theta_roll'];
                    const theta_pitch = rawRow['theta_pitch'];
                    const gyroRollRate = rawRow['Gyro Roll'];
                    const gyroPitchRate = rawRow['Gyro Pitch'];

                    // Calculate Kalman angles and store them (for tilt animation and console)
                    filteredRow['KalmanRoll'] = kalmanRoll.update(gyroRollRate, theta_roll);
                    filteredRow['KalmanPitch'] = kalmanPitch.update(gyroPitchRate, theta_pitch);
                    
                    filteredDerivedData.push(filteredRow);
                }
                
                // == STEP 3: Add tilt calculation to rawDerivedData using filtered values from STEP 2 ==
                for (let i = 0; i < rawDerivedData.length; i++) {
                    // Store filtered gyro data for tilt calculation
                    const gyroX = filteredDerivedData[i]['KalmanRoll'] || 0;  // Use filtered Kalman Roll Angle
                    const gyroY = filteredDerivedData[i]['KalmanPitch'] || 0; // Use filtered Kalman Pitch Angle
                    
                    // Calculate tilt
                    const tilt = Math.sqrt(gyroX * gyroX + gyroY * gyroY);
                    
                    // Add the tilt data to the raw dataset, as it's used for animation state
                    rawDerivedData[i].tilt = tilt;
                    rawDerivedData[i].gyroX_direction = gyroX; // Direction is also based on filtered data for smoothness
                }

                return { raw: rawDerivedData, filtered: filteredDerivedData };
            }

            const createDatasetPairs = (config) => {
                const datasets = [];
                const rawColor = config.color.replace(/, ?0\.\d+\)/, ', 0.3)').replace('rgb(', 'rgba(');
                datasets.push({ label: `Filtered ${config.label}`, data: [], borderColor: config.color, borderWidth: 2, pointRadius: 0, tension: 0.4 });
                datasets.push({ label: `Raw ${config.label}`, data: [], borderColor: rawColor, borderWidth: 1.5, pointRadius: 0, tension: 0.1, hidden: true });
                return datasets;
            };

            const createChart = (ctx, label, color) => {
                return new Chart(ctx, {
                    type: 'line',
                    data: { labels: [], datasets: createDatasetPairs({label, color}) },
                    options: { responsive: true, maintainAspectRatio: false, animation: { duration: 0 }, plugins: { legend: { display: false }, title: { display: true, text: label, color: '#f9fafb', font: { size: 12 } } }, scales: { x: { title: { display: true, text: 'Time (s)', color: '#9ca3af', font: { size: 10 } }, ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }, y: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(255, 255, 255, 0.1)' } } } }
                });
            };
            
            const createMultiLineChart = (ctx, title, datasetsConfig) => {
                 return new Chart(ctx, {
                    type: 'line',
                    data: { labels: [], datasets: datasetsConfig.flatMap(c => createDatasetPairs(c)) },
                    options: { responsive: true, maintainAspectRatio: false, animation: { duration: 0 }, plugins: { legend: { display: false }, title: { display: true, text: title, color: '#f9fafb', font: { size: 12 } } }, scales: { x: { title: { display: true, text: 'Time (s)', color: '#9ca3af', font: { size: 10 } }, ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }, y: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(255, 255, 255, 0.1)' } } } }
                });
            };

            const initCharts = () => {
                charts.altitude = createChart(document.getElementById('altitude-chart').getContext('2d'), 'Altitude (m)', 'rgba(59, 130, 246, 0.8)');
                charts.pressure = createChart(document.getElementById('pressure-chart').getContext('2d'), 'Pressure (Pa)', 'rgba(239, 68, 68, 0.8)'); // Added Pressure Chart
                charts.velocity = createChart(document.getElementById('velocity-chart').getContext('2d'), 'Velocity (m/s)', 'rgba(16, 185, 129, 0.8)');
                charts.temp = createChart(document.getElementById('temp-chart').getContext('2d'), 'Temperature (°C)', 'rgba(245, 158, 11, 0.8)');
                charts.gyro = createMultiLineChart(document.getElementById('gyro-chart').getContext('2d'), 'Gyroscope', [{ label: 'Roll', color: '#34D399' },{ label: 'Pitch', color: '#F87171' },{ label: 'Yaw', color: '#60A5FA' }]);
                charts.accel = createMultiLineChart(document.getElementById('accel-chart').getContext('2d'), 'Accelerometer', [{ label: 'AccX', color: '#A78BFA' },{ label: 'AccY', color: '#FBBF24' },{ label: 'AccZ', color: '#EC4899' }]); // Changed Labels
                charts.rotation = createMultiLineChart(document.getElementById('rotation-chart').getContext('2d'), 'Auto Rotation', [{ label: 'AutoGyro1', color: '#2DD4BF' },{ label: 'AutoGyro2', color: '#F472B6' }]);
                charts.voltage = createChart(document.getElementById('voltage-chart').getContext('2d'), 'Voltage (V)', 'rgba(139, 92, 246, 0.8)'); // Moved Voltage
            };
            
            const updateButtonStyle = (button, chart, datasetIndex) => {
                const filteredMeta = chart.getDatasetMeta(datasetIndex * 2);
                const color = chart.data.datasets[datasetIndex * 2].borderColor;
                if (filteredMeta.hidden) {
                    button.classList.add('inactive');
                    button.style.backgroundColor = '#374151'; button.style.borderColor = '#4b5563'; button.style.color = '#d1d5db'; 
                } else {
                    button.classList.remove('inactive');
                    button.style.backgroundColor = color; button.style.borderColor = color; button.style.color = '#ffffff';
                }
            };

            const setupChartToggles = () => {
                document.querySelectorAll('.chart-toggle-btn').forEach(button => {
                    const chartName = button.dataset.chart;
                    const datasetIndex = parseInt(button.dataset.dataset, 10);
                    const chart = charts[chartName];
                    if (chart) {
                        updateButtonStyle(button, chart, datasetIndex);
                        button.addEventListener('click', (event) => {
                            event.stopPropagation();
                            const filteredMeta = chart.getDatasetMeta(datasetIndex * 2);
                            const rawMeta = chart.getDatasetMeta(datasetIndex * 2 + 1);
                            const isHidden = filteredMeta.hidden === null ? true : !filteredMeta.hidden;
                            filteredMeta.hidden = isHidden;
                            rawMeta.hidden = isHidden;
                            chart.update();
                            updateButtonStyle(button, chart, datasetIndex);
                        });
                    }
                });
            };

            const resetCharts = () => {
                Object.values(charts).forEach(chart => {
                    chart.data.labels = [];
                    chart.data.datasets.forEach(dataset => dataset.data = []);
                    chart.update();
                });
                 // Also reset the modal chart if it's open
                if (modalChartInstance) {
                    modalChartInstance.data.labels = [];
                    modalChartInstance.data.datasets.forEach(dataset => {
                        dataset.data = [];
                    });
                    modalChartInstance.update();
                }
            };

            const updateButtonStates = () => {
                 // Live Telemetry: Don't update playback buttons if in live mode
                 if (isLiveMode) {
                    // In live mode, only crop and mode buttons should be potentially enabled
                    cropBtn.disabled = liveDataCounter <= 0; // Can't crop if no data
                    dataModeButton.disabled = false;
                    return;
                 } 

                 const currentAbsoluteIndex = currentIndex + cropPoint;
                 rewindBtn.disabled = currentAbsoluteIndex <= 0;
                 forwardBtn.disabled = currentAbsoluteIndex >= telemetryData.length;
                 cropBtn.disabled = currentAbsoluteIndex <= 0 || currentAbsoluteIndex >= telemetryData.length; // Can't crop at start or end
                 playPauseBtn.disabled = currentAbsoluteIndex >= telemetryData.length && endBtn.textContent !== 'Replay'; // Disable play if finished unless replay available
                 endBtn.disabled = currentAbsoluteIndex >= telemetryData.length && endBtn.textContent === 'End'; // Disable End if already at end
                 dataModeButton.disabled = telemetryData.length === 0; // Disable mode if no data
            };


            const resetState = () => {
                stopPlotting();
                telemetryData = [];
                filteredTelemetryData = [];
                cropPoint = 0; // Reset crop point
                P0 = null; // Reset P0
                
                // Live Telemetry: Reset Live Mode specific state
                isLiveMode = false; 
                liveDataCounter = 0; 
                lastFilteredValues = {}; 
                lastRawAltitude = 0; 
                
                // Keep Data Mode enabled if live was active? Re-disable for now.
                [downloadCsvButton, dataModeButton, cropBtn].forEach(btn => btn.disabled = true);
                resetCharts();
                videoUpContainer.innerHTML = '<span>Video Player</span>'; // Updated placeholder
                fullscreenBtn.style.display = 'none'; // Hide fullscreen button
                if(tiltIndicator) tiltIndicator.style.transform = 'rotate(0deg)';
                rollReadout.textContent = 'Roll: 0.00°'; // Reset readout
                pitchReadout.textContent = 'Pitch: 0.00°'; // Reset readout
                
                 // Only disable playback controls on reset, keep blink enabled
                [rewindBtn, playPauseBtn, forwardBtn, speedBtn, endBtn].forEach(btn => btn.disabled = true); 
                playPauseBtn.textContent = 'Play';
                speedBtn.textContent = '1x';
                endBtn.textContent = 'End';
                dataModeButton.textContent = 'Mode: Filtered';
                isPaused = true;
                playbackSpeed = 1;
                currentIndex = 0;
                dataDisplayMode = 'filtered';

                 // Reset Live button text and style
                 liveModeBtn.textContent = 'Live : Off';
                 liveModeBtn.classList.remove('bg-red-600', 'hover:bg-red-700', 'live-on');
                 liveModeBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                 // Ensure upload buttons are enabled when not in live mode after reset
                 [uploadButton, uploadCsvButton].forEach(btn => btn.disabled = false);

                 // Reset Kalman Filters
                 kalmanRoll.reset();
                 kalmanPitch.reset();
            };

            // File Handling
            uploadButton.addEventListener('click', () => zipInput.click());
            uploadCsvButton.addEventListener('click', () => csvInput.click());
            zipInput.addEventListener('change', (e) => e.target.files[0] && handleZipFile(e.target.files[0]));
            csvInput.addEventListener('change', (e) => e.target.files[0] && handleCsvFile(e.target.files[0]));

            const handleZipFile = (file) => {
                // if (isLiveMode) toggleLiveMode(); // Now handled by resetState if needed
                resetState();
                JSZip.loadAsync(file).then(zip => {
                    let csvFound = false;
                    let videoFound = false; // Flag to process only the first video
                    zip.forEach((_, zipEntry) => {
                        // Look for the first video file (.mp4)
                        if (!videoFound && zipEntry.name.toLowerCase().endsWith('.mp4')) {
                            videoFound = true; // Mark video as found
                            zipEntry.async('blob').then(blob => {
                                const videoURL = URL.createObjectURL(blob);
                                const videoElement = document.createElement('video');
                                videoElement.src = videoURL; 
                                videoElement.loop = false; 
                                videoElement.muted = true;
                                videoUpContainer.innerHTML = ''; 
                                videoUpContainer.appendChild(videoElement);
                                fullscreenBtn.style.display = 'block'; // Show fullscreen button
                            });
                        }
                        if (!csvFound && zipEntry.name.toLowerCase().endsWith('.csv')) {
                           csvFound = true;
                           zipEntry.async('string').then(csvData => parseAndPlotData(csvData));
                        }
                    });
                     if (!videoFound) {
                        videoUpContainer.innerHTML = '<span>No video found in ZIP</span>';
                         fullscreenBtn.style.display = 'none';
                    }
                }).catch(err => {
                    console.error("Error reading zip file:", err);
                    videoUpContainer.innerHTML = '<span>Error reading ZIP</span>';
                     fullscreenBtn.style.display = 'none';
                });
            };

            const handleCsvFile = (file) => {
                // if (isLiveMode) toggleLiveMode(); // Handled by resetState
                resetState();
                const reader = new FileReader();
                reader.onload = (e) => parseAndPlotData(e.target.result);
                reader.readAsText(file);
            };

            const parseAndPlotData = (csvData) => {
                Papa.parse(csvData, {
                    header: true, dynamicTyping: true, skipEmptyLines: true,
                    complete: (results) => {
                        const rawCsvData = results.data;
                        
                        // Set P0 based on the first valid pressure reading
                        const firstValidPressureRow = rawCsvData.find(row => row && (Number(row['Pressure']) || 0) > 0);
                        P0 = firstValidPressureRow ? (Number(firstValidPressureRow['Pressure']) / 100.0) : 1013.25; // Set P0 in hPa
                        console.log("P0 set for file to:", P0);
                        
                        const { raw, filtered } = processAndFilterData(rawCsvData, P0); // Pass P0
                        telemetryData = raw;
                        filteredTelemetryData = filtered;
                        
                        [downloadCsvButton, dataModeButton].forEach(btn => btn.disabled = false);
                        // Enable playback controls and Crop
                        [rewindBtn, playPauseBtn, forwardBtn, speedBtn, endBtn, cropBtn].forEach(btn => btn.disabled = false); 
                        isPaused = true;
                        playPauseBtn.textContent = 'Play';
                        updateAllChartModes();
                        updateButtonStates(); // Update initial button disabled states
                    },
                    error: (err) => console.error("Error parsing CSV:", err)
                });
            };

            const addDataToCharts = (index) => {
                // Use absolute index for data fetching
                const absoluteIndex = index + cropPoint;
                if (absoluteIndex >= telemetryData.length) return; 

                const rawRow = telemetryData[absoluteIndex];
                const filteredRow = filteredTelemetryData[absoluteIndex];
                const label = index; // Label is relative to cropPoint

                const pushData = (chart, keys) => {
                    chart.data.labels.push(label); // Use relative label
                    keys.forEach(key => {
                        // Check if dataset exists before trying to push data
                        if (chart.data.datasets[key.index * 2] && chart.data.datasets[key.index * 2 + 1]) {
                             chart.data.datasets[key.index * 2].data.push(filteredRow[key.f_name]);
                             chart.data.datasets[key.index * 2 + 1].data.push(rawRow[key.r_name]);
                        } else {
                            console.error(`Dataset index ${key.index*2} or ${key.index*2+1} not found for key ${key.name}`);
                        }
                    });
                };
                
                pushData(charts.altitude, [{ f_name: 'Altitude', r_name: 'Altitude', index: 0 }]);
                pushData(charts.pressure, [{ f_name: 'Pressure', r_name: 'Pressure', index: 0 }]);
                pushData(charts.velocity, [{ f_name: 'Velocity', r_name: 'Velocity', index: 0 }]);
                pushData(charts.temp, [{ f_name: 'Temperature', r_name: 'Temperature', index: 0 }]);
                pushData(charts.voltage, [{ f_name: 'Voltage', r_name: 'Voltage', index: 0 }]); 
                // Reverted Gyro chart to plot rates.
                pushData(charts.gyro, [{ f_name: 'Gyro Roll', r_name: 'Gyro Roll', index: 0 }, { f_name: 'Gyro Pitch', r_name: 'Gyro Pitch', index: 1 }, { f_name: 'Gyro Yaw', r_name: 'Gyro Yaw', index: 2 }]);
                pushData(charts.accel, [{ f_name: 'AccX', r_name: 'AccX', index: 0 }, { f_name: 'AccY', r_name: 'AccY', index: 1 }, { f_name: 'AccZ', r_name: 'AccZ', index: 2 }]); 
                pushData(charts.rotation, [{ f_name: 'Auto Rotation 1', r_name: 'Auto Rotation 1', index: 0 }, { f_name: 'Auto Rotation 2', r_name: 'Auto Rotation 2', index: 1 }]);
            };
            
             // Live Telemetry: Function to plot a single live data point
            const plotSingleLivePoint = (rawRow, filteredRow) => {
                const label = liveDataCounter++; // Use a simple counter for labels

                const pushLiveData = (chart, keys) => {
                    chart.data.labels.push(label);
                     // Optional: Limit history length in live mode
                     const maxLivePoints = 100; // Keep last 100 points
                     if(chart.data.labels.length > maxLivePoints) {
                         chart.data.labels.shift();
                     }

                    keys.forEach(key => {
                        if (chart.data.datasets[key.index * 2] && chart.data.datasets[key.index * 2 + 1]) {
                             chart.data.datasets[key.index * 2].data.push(filteredRow[key.f_name]);
                             chart.data.datasets[key.index * 2 + 1].data.push(rawRow[key.r_name]);
                             // Optional: Limit history length
                             if(chart.data.datasets[key.index * 2].data.length > maxLivePoints) {
                                 chart.data.datasets[key.index * 2].data.shift();
                                 chart.data.datasets[key.index * 2 + 1].data.shift();
                             }
                        }
                    });
                };
                
                pushLiveData(charts.altitude, [{ f_name: 'Altitude', r_name: 'Altitude', index: 0 }]);
                pushLiveData(charts.pressure, [{ f_name: 'Pressure', r_name: 'Pressure', index: 0 }]);
                pushLiveData(charts.velocity, [{ f_name: 'Velocity', r_name: 'Velocity', index: 0 }]);
                pushLiveData(charts.temp, [{ f_name: 'Temperature', r_name: 'Temperature', index: 0 }]);
                pushLiveData(charts.voltage, [{ f_name: 'Voltage', r_name: 'Voltage', index: 0 }]); 
                // Reverted Gyro chart to plot rates.
                pushLiveData(charts.gyro, [{ f_name: 'Gyro Roll', r_name: 'Gyro Roll', index: 0 }, { f_name: 'Gyro Pitch', r_name: 'Gyro Pitch', index: 1 }, { f_name: 'Gyro Yaw', r_name: 'Gyro Yaw', index: 2 }]);
                pushLiveData(charts.accel, [{ f_name: 'AccX', r_name: 'AccX', index: 0 }, { f_name: 'AccY', r_name: 'AccY', index: 1 }, { f_name: 'AccZ', r_name: 'AccZ', index: 2 }]); 
                pushLiveData(charts.rotation, [{ f_name: 'Auto Rotation 1', r_name: 'Auto Rotation 1', index: 0 }, { f_name: 'Auto Rotation 2', r_name: 'Auto Rotation 2', index: 1 }]);

                 Object.values(charts).forEach(chart => chart.update());
                 updateAllChartModes(); // Ensure mode visibility is correct for live data

                 // Tilt Animation Update (still uses Kalman angles)
                if (tiltIndicator) {
                    const tiltAngle = Math.sqrt(filteredRow['KalmanRoll']**2 + filteredRow['KalmanPitch']**2);
                    const direction = filteredRow['KalmanRoll'] > 0 ? 1 : -1;
                    // Apply animation directly here for live data
                    tiltIndicator.style.transition = 'transform 0.1s linear'; // Faster transition for live
                    tiltIndicator.style.transform = `rotate(${tiltAngle * direction}deg)`;
                }

                // Log calculated angles to console AND update readouts
                const kalmanRollAngle = filteredRow['KalmanRoll'];
                const kalmanPitchAngle = filteredRow['KalmanPitch'];
                console.log(`Kalman Roll: ${kalmanRollAngle.toFixed(2)}, Kalman Pitch: ${kalmanPitchAngle.toFixed(2)}`);
                rollReadout.textContent = `Roll: ${kalmanRollAngle.toFixed(2)}°`;
                pitchReadout.textContent = `Pitch: ${kalmanPitchAngle.toFixed(2)}°`;
            };


            const plotNextPoint = () => {
                const absoluteIndex = currentIndex + cropPoint;
                if (isPaused || absoluteIndex >= telemetryData.length) {
                    if (absoluteIndex >= telemetryData.length) stopPlotting(true);
                    return;
                }
                addDataToCharts(currentIndex); // Pass relative index
                Object.values(charts).forEach(chart => chart.update());
                
                // Tilt Animation Update (uses absolute index for data)
                if (tiltIndicator && telemetryData[absoluteIndex]) {
                    const currentRawData = telemetryData[absoluteIndex];
                    const tiltAngle = currentRawData.tilt;
                    const direction = currentRawData.gyroX_direction > 0 ? 1 : -1;
                     // Ensure slower transition for playback
                    tiltIndicator.style.transition = 'transform 1s linear'; 
                    tiltIndicator.style.transform = `rotate(${tiltAngle * direction}deg)`;
                }

                // Log calculated angles to console AND update readouts
                if (filteredTelemetryData[absoluteIndex]) {
                    const currentFilteredData = filteredTelemetryData[absoluteIndex];
                    const kalmanRollAngle = currentFilteredData['KalmanRoll'];
                    const kalmanPitchAngle = currentFilteredData['KalmanPitch'];
                    console.log(`Kalman Roll: ${kalmanRollAngle.toFixed(2)}, Kalman Pitch: ${kalmanPitchAngle.toFixed(2)}`);
                    rollReadout.textContent = `Roll: ${kalmanRollAngle.toFixed(2)}°`;
                    pitchReadout.textContent = `Pitch: ${kalmanPitchAngle.toFixed(2)}°`;
                }


                if (modalChartInstance) {
                    const rawRow = telemetryData[absoluteIndex];
                    const filteredRow = filteredTelemetryData[absoluteIndex];
                    
                    const displayLabel = currentIndex; // Use relative index for label
                    modalChartInstance.data.labels.push(displayLabel);

                    for (let i = 0; i < modalChartInstance.data.datasets.length / 2; i++) {
                         const filteredDs = modalChartInstance.data.datasets[i * 2];
                         const rawDs = modalChartInstance.data.datasets[i * 2 + 1];
                        
                         const key = filteredDs.label.replace('Filtered ', '');
                        
                         let rawValue, filteredValue;

                         // Updated keyMap/multiKeyMap
                         const keyMap = { 'Altitude (m)': 'Altitude', 'Pressure (Pa)': 'Pressure', 'Velocity (m/s)': 'Velocity', 'Temperature (°C)': 'Temperature', 'Voltage (V)': 'Voltage'};
                         // Gyro chart plots rates, so multiKeyMap reflects this
                         const multiKeyMap = { 
                             Roll: { f: 'Gyro Roll', r: 'Gyro Roll' }, 
                             Pitch: { f: 'Gyro Pitch', r: 'Gyro Pitch' }, 
                             Yaw: { f: 'Gyro Yaw', r: 'Gyro Yaw' }, 
                             AccX: { f: 'AccX', r: 'AccX' }, 
                             AccY: { f: 'AccY', r: 'AccY' }, 
                             AccZ: { f: 'AccZ', r: 'AccZ' }, 
                             AutoGyro1: { f: 'Auto Rotation 1', r: 'Auto Rotation 1' }, 
                             AutoGyro2: { f: 'Auto Rotation 2', r: 'Auto Rotation 2' }
                         };
                         let dataFieldName;
                         let sourceDataArray;

                         if (keyMap[key]) {
                             dataFieldName = keyMap[key];
                             sourceDataArray = isRaw ? telemetryData[absoluteIndex] : filteredTelemetryData[absoluteIndex];
                             rawValue = rawRow[dataFieldName];
                             filteredValue = filteredRow[dataFieldName];
                         } else if (multiKeyMap[key]) {
                             const fieldName = multiKeyMap[key].f; // f_name and r_name are the same now
                             rawValue = rawRow[fieldName];
                             filteredValue = filteredRow[fieldName];
                         }
                        
                         filteredDs.data.push(filteredValue);
                         rawDs.data.push(rawValue);
                    }
                    modalChartInstance.update('none');
                }
                currentIndex++; // Increment relative index
                updateButtonStates(); // Update buttons every step
            };
            
            const startPlotting = () => {
                // Live Telemetry: Don't start interval timer in live mode
                if (isLiveMode) return; 
                if (plotInterval) clearInterval(plotInterval);
                plotInterval = setInterval(plotNextPoint, 1000 / playbackSpeed);
            };

            const stopPlotting = (finished = false) => {
                 // Live Telemetry: Don't clear interval if it wasn't set (i.e., in live mode)
                if (plotInterval) clearInterval(plotInterval); 
                plotInterval = null;
                isPaused = true;
                playPauseBtn.textContent = 'Play';
                if (finished && !isLiveMode) { // Only show finished/replay if not live
                    playPauseBtn.textContent = 'Finished';
                    playPauseBtn.disabled = true;
                    endBtn.textContent = 'Replay';
                    endBtn.disabled = false;
                }
                getVideos().forEach(v => v.pause()); // Adjusted function name
                updateButtonStates(); // Update buttons when stopping
            };

            // Renamed function, now only gets the 'up' video
            const getVideos = () => [videoUpContainer.querySelector('video')].filter(Boolean); 

            const togglePlayPause = () => {
                 // Live Telemetry: Don't allow play/pause in live mode
                 if (isLiveMode) return; 

                const absoluteIndex = currentIndex + cropPoint;
                if (telemetryData.length === 0 || absoluteIndex >= telemetryData.length) return;
                isPaused = !isPaused;
                playPauseBtn.textContent = isPaused ? 'Play' : 'Pause';
                const videos = getVideos(); // Adjusted function name
                if (isPaused) videos.forEach(v => v.pause());
                else {
                    videos.forEach(v => { 
                        const videoTime = absoluteIndex / playbackSpeed; // Video time based on absolute index
                        v.currentTime = videoTime; 
                        v.playbackRate = playbackSpeed; 
                        v.play(); 
                    });
                    if (!plotInterval) startPlotting();
                }
                 updateButtonStates();
            };
            
            const seek = (seconds) => {
                 // Live Telemetry: Don't allow seeking in live mode
                 if (isLiveMode) return; 

                if (telemetryData.length === 0) return;
                
                const currentAbsoluteIndex = currentIndex + cropPoint;
                let newAbsoluteIndex = Math.max(0, Math.min(currentAbsoluteIndex + seconds, telemetryData.length));
                
                const newRelativeIndex = newAbsoluteIndex - cropPoint; // Calculate the new relative index

                const wasPaused = isPaused;
                
                stopPlotting(); 
                currentIndex = newRelativeIndex; // Update the relative index
                resetCharts();
                
                // Rebuild charts from the cropPoint up to the new absolute index
                for (let i = cropPoint; i < newAbsoluteIndex; i++) { 
                    addDataToCharts(i - cropPoint); // Pass relative index for label, fetch data using absolute index i implicitly
                }
                
                updateOnSeekOrModeChange(); // Updates charts and modal

                const videoTime = newAbsoluteIndex / playbackSpeed; // Video time based on absolute index
                getVideos().forEach(v => v.currentTime = videoTime); 

                if (!wasPaused && newAbsoluteIndex < telemetryData.length) {
                    isPaused = false;
                    playPauseBtn.textContent = 'Pause';
                    playPauseBtn.disabled = false;
                    startPlotting();
                    getVideos().forEach(v => { v.playbackRate = playbackSpeed; v.play(); }); // Adjusted function name
                } else if (newAbsoluteIndex >= telemetryData.length) stopPlotting(true);
                 updateButtonStates();
            };

            const seekToEnd = () => {
                 // Live Telemetry: Don't allow seek to end in live mode
                 if (isLiveMode) return; 

                if (telemetryData.length === 0) return;
                const absoluteEndIndex = telemetryData.length;
                
                stopPlotting();
                currentIndex = absoluteEndIndex - cropPoint; // Set relative index to the end
                resetCharts();
                for (let i = cropPoint; i < absoluteEndIndex; i++) { 
                    addDataToCharts(i - cropPoint); // Build up to the end
                }
                updateOnSeekOrModeChange();
                
                const videoTime = Math.max(0, absoluteEndIndex -1) / playbackSpeed; // Video time based on absolute index
                getVideos().forEach(v => v.currentTime = videoTime); 
                stopPlotting(true);
                updateButtonStates();
            };
            
            const replayPlayback = () => {
                 // Live Telemetry: Don't allow replay in live mode
                 if (isLiveMode) return; 

                stopPlotting();
                currentIndex = 0; // Reset relative index
                cropPoint = 0; // Reset crop point
                playbackSpeed = 1;
                resetCharts();

                getVideos().forEach(v => { v.currentTime = 0; v.playbackRate = playbackSpeed; }); // Adjusted function name
                playPauseBtn.disabled = false; playPauseBtn.textContent = 'Play';
                speedBtn.textContent = '1x'; endBtn.textContent = 'End';
                isPaused = true; 
                togglePlayPause(); // Will call updateButtonStates inside
            };

             // Crop Functionality (Visual Reset)
            const cropData = () => {
                 if (isLiveMode) {
                     // Live Mode: Clear current chart data and reset counters/state
                     resetCharts();
                     liveDataCounter = 0;
                     lastFilteredValues = {};
                     lastRawAltitude = 0;
                     kalmanRoll.reset(); // Reset kalman filters
                     kalmanPitch.reset();
                     P0 = null; // Reset P0 for live data
                     console.log("Live data view cleared.");
                 } else {
                    // File Playback Mode: Set crop point
                    const absoluteIndex = currentIndex + cropPoint;
                    if (telemetryData.length === 0 || absoluteIndex <= 0 || absoluteIndex >= telemetryData.length) return; 

                    const wasPaused = isPaused;
                    stopPlotting();

                    cropPoint = absoluteIndex; // Set the new crop starting point
                    currentIndex = 0; // Reset the relative index

                    resetCharts(); // Clear visual charts
                    
                    // Set video time to the crop point
                    const videoTime = cropPoint / playbackSpeed;
                    getVideos().forEach(v => v.currentTime = videoTime);

                    updateButtonStates(); // Update buttons after cropping

                    // If it was playing, resume from the new start
                    if (!wasPaused) {
                       togglePlayPause();
                    } else {
                         // If paused, update the tilt indicator AND readouts to the new starting position
                        if (tiltIndicator && telemetryData[cropPoint] && filteredTelemetryData[cropPoint]) { 
                            const firstRawData = telemetryData[cropPoint];
                            const firstFilteredData = filteredTelemetryData[cropPoint]; 
                            const tiltAngle = firstRawData.tilt;
                            const direction = firstRawData.gyroX_direction > 0 ? 1 : -1;
                            tiltIndicator.style.transform = `rotate(${tiltAngle * direction}deg)`;
                            
                            // Update readouts to the new start point
                            const kalmanRollAngle = firstFilteredData['KalmanRoll']; 
                            const kalmanPitchAngle = firstFilteredData['KalmanPitch']; 
                            rollReadout.textContent = `Roll: ${kalmanRollAngle.toFixed(2)}°`; 
                            pitchReadout.textContent = `Pitch: ${kalmanPitchAngle.toFixed(2)}°`; 
                        }
                    }
                }
            };


            const handleEndReplayClick = () => { endBtn.textContent === 'End' ? seekToEnd() : replayPlayback(); };
            const changeSpeed = () => {
                // Live Telemetry: Don't allow speed change in live mode
                if (isLiveMode) return; 
                
                if(telemetryData.length === 0) return;
                playbackSpeed = playbackSpeed === 1 ? 2 : 1;
                speedBtn.textContent = `${playbackSpeed}x`;
                getVideos().forEach(v => v.playbackRate = playbackSpeed); // Adjusted function name
                if (!isPaused) startPlotting(); // Restart plotting interval with new speed
            };

            // --- MQTT Setup ---
            const brokerAddress = 'wss://broker.hivemq.com:8884/mqtt'; 
            const dataTopic = 'Aerobits/data'; // Live Telemetry: Topic for incoming data
            const commandTopic = 'Aerobits'; // Corrected topic for blink command

            const client = mqtt.connect(brokerAddress);

            client.on('connect', () => {
                console.log('Connected to MQTT broker!');
                blinkBtn.disabled = false; 
                // Live Telemetry: Subscribe to data topic on connect
                client.subscribe(dataTopic, (err) => {
                    if (!err) {
                        console.log(`Subscribed to ${dataTopic}`);
                    } else {
                         console.error(`Failed to subscribe to ${dataTopic}:`, err);
                    }
                });
            });

            client.on('error', (err) => {
                console.error('MQTT Connection Error:', err);
                 // blinkBtn.disabled = true; 
            });

            // Live Telemetry: Handle incoming messages
             client.on('message', (topic, message) => {
                if (topic === dataTopic && isLiveMode) {
                    try {
                        const messageString = message.toString();
                        const values = messageString.split(',').map(Number); // [Temp, Press(Pa), Volt, gyro r, p, y, accX,Y,Z, auto rot 1, auto rot 2]
                        
                        if (values.length >= 11) {
                            // const P0 = 1013.25; // Corrected P0 (hPa)
                            
                            // --- SANITIZATION for Live Data ---
                            const liveRawRow = {
                                'Temperature': Number(values[0]) || 0,
                                'Pressure': Number(values[1]) || 0, // Pressure in Pa
                                'Voltage': Number(values[2]) || 0,
                                'Gyro Roll': Number(values[3]) || 0,
                                'Gyro Pitch': Number(values[4]) || 0,
                                'Gyro Yaw': Number(values[5]) || 0,
                                'AccX': Number(values[6]) || 0, 
                                'AccY': Number(values[7]) || 0, 
                                'AccZ': Number(values[8]) || 0, 
                                'Auto Rotation 1': Number(values[9]) || 0,
                                'Auto Rotation 2': Number(values[10]) || 0,
                            };
                            // --- END SANITIZATION ---

                            // Calculate derived raw values
                            const pressurePa = liveRawRow['Pressure'];
                            const pressureHpa = pressurePa / 100.0; // Convert Pa to hPa for calculation
                            
                            // Set P0 on the very first valid live packet
                            if (P0 === null) {
                                P0 = (pressureHpa > 0) ? pressureHpa : 1013.25; 
                                console.log("P0 set for live data to:", P0);
                            }

                            liveRawRow['Altitude'] = (pressureHpa === null || pressureHpa <= 0) ? 0 : 44330 * (1 - Math.pow(pressureHpa / P0, 1 / 5.255));
                            liveRawRow['Velocity'] = calculateSingleVelocity(liveRawRow['Altitude']); // Use live velocity calc
                            const { theta_roll, theta_pitch } = getAccelAngles(liveRawRow['AccX'], liveRawRow['AccY'], liveRawRow['AccZ']);
                            liveRawRow['theta_roll'] = theta_roll;
                            liveRawRow['theta_pitch'] = theta_pitch;

                            // Calculate filtered values for this point
                            const liveFilteredRow = {};
                             // Updated keysToFilter
                            const keysToFilter = ['Pressure', 'Altitude', 'Velocity', 'Temperature', 'Voltage', 'Gyro Roll', 'Gyro Pitch', 'Gyro Yaw', 'AccX', 'AccY', 'AccZ', 'Auto Rotation 1', 'Auto Rotation 2'];
                            keysToFilter.forEach(key => {
                                 liveFilteredRow[key] = emaFilterSinglePoint(key, liveRawRow[key]);
                            });
                            
                            // Live Kalman Filter Update
                            liveFilteredRow['KalmanRoll'] = kalmanRoll.update(liveRawRow['Gyro Roll'], liveRawRow['theta_roll']);
                            liveFilteredRow['KalmanPitch'] = kalmanPitch.update(liveRawRow['Gyro Pitch'], liveRawRow['theta_pitch']);

                             // Calculate tilt based on filtered live values
                            const gyroX_f = liveFilteredRow['KalmanRoll'] || 0;
                            const gyroY_f = liveFilteredRow['KalmanPitch'] || 0;
                            liveFilteredRow.tilt = Math.sqrt(gyroX_f**2 + gyroY_f**2);
                            liveFilteredRow.gyroX_direction = gyroX_f;


                            plotSingleLivePoint(liveRawRow, liveFilteredRow);
                        } else {
                            console.warn("Received MQTT message with incorrect number of values:", messageString);
                        }
                    } catch (e) {
                        console.error("Error processing MQTT message:", e);
                    }
                }
            });


            const blinkLED = () => {
                if (client && client.connected) {
                    client.publish(commandTopic, "0");
                    console.log(`Published "0" to topic "${commandTopic}"`);
                } else {
                    console.error("MQTT client not connected. Cannot publish message.");
                }
            }

            // Live Telemetry: Toggle Live Mode Button Functionality
            const toggleLiveMode = () => {
                isLiveMode = !isLiveMode; // Toggle the state

                if (isLiveMode) {
                    liveModeBtn.textContent = 'Live : On';
                    liveModeBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    liveModeBtn.classList.add('bg-red-600', 'hover:bg-red-700', 'live-on');
                    client.publish(commandTopic, "1");
                    
                    stopPlotting(); // Stop playback if running
                    currentIndex = 0; // Reset playback index
                    cropPoint = 0; // Reset crop point
                    telemetryData = []; // Clear playback data arrays
                    filteredTelemetryData = [];
                    resetCharts(); // Clear charts visually
                    liveDataCounter = 0; // Reset live counter
                    lastFilteredValues = {}; // Reset EMA state
                    lastRawAltitude = 0; // Reset velocity state
                    kalmanRoll.reset(); // Reset kalman filters
                    kalmanPitch.reset();
                    P0 = null; // Reset P0 for live data

                    // Disable file/playback controls, enable Crop and Mode
                    [uploadButton, uploadCsvButton, downloadCsvButton, rewindBtn, playPauseBtn, forwardBtn, speedBtn, endBtn].forEach(btn => btn.disabled = true);
                    [cropBtn, dataModeButton].forEach(btn => btn.disabled = false); // Enable Crop and Mode in Live
                    getVideos().forEach(v => v.pause()); 
                    videoUpContainer.innerHTML = '<span>Video disabled in Live Mode</span>'; // Indicate video is off
                    fullscreenBtn.style.display = 'none';


                } else {
                    liveModeBtn.textContent = 'Live : Off';
                     liveModeBtn.classList.remove('bg-red-600', 'hover:bg-red-700', 'live-on');
                     liveModeBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                     client.publish(commandTopic, "2");
                    
                    // Re-enable file uploads, disable everything else until file load
                    [uploadButton, uploadCsvButton].forEach(btn => btn.disabled = false);
                    [downloadCsvButton, dataModeButton, rewindBtn, playPauseBtn, forwardBtn, speedBtn, endBtn, cropBtn].forEach(btn => btn.disabled = true);
                     videoUpContainer.innerHTML = '<span>Video Player</span>'; // Restore placeholder
                     resetState(); // Fully reset to initial state after turning live off (will re-enable upload buttons)
                }
            }

             // Fullscreen functionality
            fullscreenBtn.addEventListener('click', () => {
                const videoElement = videoUpContainer.querySelector('video');
                if (!videoElement) return;

                if (!document.fullscreenElement) {
                    if (videoElement.requestFullscreen) {
                        videoElement.requestFullscreen();
                    } else if (videoElement.webkitRequestFullscreen) { /* Safari */
                        videoElement.webkitRequestFullscreen();
                    } else if (videoElement.msRequestFullscreen) { /* IE11 */
                        videoElement.msRequestFullscreen();
                    }
                } else {
                     if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) { /* Safari */
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) { /* IE11 */
                        document.msExitFullscreen();
                    }
                }
            });

            playPauseBtn.addEventListener('click', togglePlayPause);
            rewindBtn.addEventListener('click', () => seek(-5));
            forwardBtn.addEventListener('click', () => seek(5));
            speedBtn.addEventListener('click', changeSpeed);
            endBtn.addEventListener('click', handleEndReplayClick);
            cropBtn.addEventListener('click', cropData); // Add click listener for Crop button
            blinkBtn.addEventListener('click', blinkLED); 
            liveModeBtn.addEventListener('click', toggleLiveMode); // Add click listener for Live button

            downloadCsvButton.addEventListener('click', () => {
                 // Live Telemetry: Disable download in live mode
                 if (isLiveMode) {
                     console.log("Download disabled in Live Mode.");
                     return; 
                 }
                if (!telemetryData || telemetryData.length === 0) return;

                let dataToDownload;
                let downloadOptions = {};
                // Updated downloadKeys to include Pressure & AccX/Y/Z
                const downloadKeys = [
                    'Altitude', 'Pressure', 'Velocity', 'Temperature', 'Voltage',
                    'Gyro Roll', 'Gyro Pitch', 'Gyro Yaw',
                    'AccX', 'AccY', 'AccZ', // Changed keys
                    'Auto Rotation 1', 'Auto Rotation 2'
                ];
                
                // Adjust data for download based on crop point
                const startIndex = cropPoint;
                const endIndex = telemetryData.length;

                if (dataDisplayMode === 'filtered') {
                    dataToDownload = filteredTelemetryData.slice(startIndex, endIndex);
                    downloadOptions.fields = downloadKeys;
                } else if (dataDisplayMode === 'raw') {
                    dataToDownload = telemetryData.slice(startIndex, endIndex);
                    downloadOptions.fields = downloadKeys;
                } else { // 'compare' mode
                    const compareData = [];
                    for (let i = startIndex; i < endIndex; i++) {
                        const newRow = {};
                        downloadKeys.forEach(key => {
                            newRow[`${key} (Filtered)`] = filteredTelemetryData[i] ? filteredTelemetryData[i][key] : null;
                            newRow[`${key} (Raw)`] = telemetryData[i] ? telemetryData[i][key] : null;
                        });
                        compareData.push(newRow);
                    }
                    dataToDownload = compareData;
                }

                const csv = Papa.unparse(dataToDownload, downloadOptions);
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = `telemetry_data_${dataDisplayMode}_cropped.csv`; // Indicate cropping in filename
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });

            function hexToRgba(hex, alpha) {
                let r = 0, g = 0, b = 0;
                if (hex.length === 4) { // #RGB
                    r = "0x" + hex[1] + hex[1]; g = "0x" + hex[2] + hex[2]; b = "0x" + hex[3] + hex[3];
                } else if (hex.length === 7) { // #RRGGBB
                    r = "0x" + hex[1] + hex[2]; g = "0x" + hex[3] + hex[4]; b = "0x" + hex[5] + hex[6];
                }
                return `rgba(${+r},${+g},${+b},${alpha})`;
            }

            const updateOnSeekOrModeChange = () => {
                Object.values(charts).forEach(chart => chart.update());

                if (modalChartInstance) {
                    const originalChart = modalChartInstance.originalChart;
                    
                    // Rebuild modal data based on current state (cropPoint, currentIndex)
                    const modalData = { labels: [], datasets: [] };
                     let startIndex, endIndex;
                     let sourceLabels;

                     if (isLiveMode) {
                         sourceLabels = originalChart.data.labels.slice(); // Copy live labels
                         startIndex = 0;
                         endIndex = sourceLabels.length;
                     } else {
                         startIndex = cropPoint;
                         endIndex = currentIndex + cropPoint;
                         sourceLabels = Array.from({length: currentIndex}, (_, i) => i); // Generate relative labels
                     }

                    modalData.labels = sourceLabels;

                     originalChart.data.datasets.forEach((originalDs, dsIndex) => {
                         const isRaw = dsIndex % 2 !== 0;
                         const dataArray = isRaw ? telemetryData : filteredTelemetryData;
                         const dataKey = isRaw ? originalDs.label.replace('Raw ', '') : originalDs.label.replace('Filtered ', '');
                         
                         // Updated keyMap/multiKeyMap
                         const keyMap = { 'Altitude (m)': 'Altitude', 'Pressure (Pa)': 'Pressure', 'Velocity (m/s)': 'Velocity', 'Temperature (°C)': 'Temperature', 'Voltage (V)': 'Voltage'};
                         const multiKeyMap = { 
                             Roll: { f: 'Gyro Roll', r: 'Gyro Roll' }, // Reverted: Plot rates
                             Pitch: { f: 'Gyro Pitch', r: 'Gyro Pitch' }, // Reverted: Plot rates
                             Yaw: { f: 'Gyro Yaw', r: 'Gyro Yaw' }, 
                             AccX: { f: 'AccX', r: 'AccX' }, 
                             AccY: { f: 'AccY', r: 'AccY' }, 
                             AccZ: { f: 'AccZ', r: 'AccZ' }, 
                             AutoGyro1: { f: 'Auto Rotation 1', r: 'Auto Rotation 1' }, 
                             AutoGyro2: { f: 'Auto Rotation 2', r: 'Auto Rotation 2' }
                         };
                         let dataFieldName;
                         let sourceDataArray;

                         if (keyMap[dataKey]) {
                             dataFieldName = keyMap[dataKey];
                             sourceDataArray = dataArray;
                         } else if (multiKeyMap[dataKey]) {
                             dataFieldName = isRaw ? multiKeyMap[dataKey].r : multiKeyMap[dataKey].f;
                             sourceDataArray = isRaw ? telemetryData : filteredTelemetryData; // Raw data from telemetryData, Filtered from filteredTelemetryData
                         }

                         let slicedData;
                          if (isLiveMode) {
                                slicedData = originalDs.data.slice(); // Use current live data
                         } else {
                              slicedData = sourceDataArray.slice(startIndex, endIndex).map(row => row ? row[dataFieldName] : null); // Add safety check for row
                         }
                        
                         modalData.datasets.push({
                            ...originalDs, // Copy style properties
                            data: slicedData,
                            hidden: !originalChart.isDatasetVisible(dsIndex) // Maintain visibility
                         });
                    });

                    modalChartInstance.data = modalData;
                    modalChartInstance.update('none');
                }
                updateButtonStates(); // Update buttons whenever seek/mode changes
            };
            
            const updateAllChartModes = () => {
                Object.values(charts).forEach(chart => {
                    chart.data.datasets.forEach((dataset, i) => {
                        if (i % 2 !== 0) return; // Operate on pairs

                        const filteredDataset = chart.data.datasets[i];
                        const rawDataset = chart.data.datasets[i + 1];
                        
                        const originalColor = filteredDataset.borderColor;
                        let lowOpacityColor;
                        if (originalColor.startsWith('#')) {
                            lowOpacityColor = hexToRgba(originalColor, 0.3);
                        } else { // Assume rgba
                            lowOpacityColor = originalColor.replace(/, ?\d?\.?\d+\)/, ', 0.3)');
                        }

                        if (dataDisplayMode === 'filtered') {
                            filteredDataset.hidden = false;
                            rawDataset.hidden = true;
                        } else if (dataDisplayMode === 'raw') {
                            filteredDataset.hidden = true;
                            rawDataset.hidden = false;
                            rawDataset.borderColor = originalColor; // Raw takes full opacity color
                        } else { // compare
                            filteredDataset.hidden = false;
                            rawDataset.hidden = false;
                            rawDataset.borderColor = lowOpacityColor; // Raw gets low opacity color
                        }
                    });

                    // Re-apply individual toggles after setting the mode visibility
                    for (let j = 0; j < chart.data.datasets.length / 2; j++) {
                        if (!chart.isDatasetVisible(j*2) && !chart.isDatasetVisible(j*2+1)) {
                            const filteredMeta = chart.getDatasetMeta(j * 2);
                            if (filteredMeta.hidden) {
                                chart.data.datasets[j * 2].hidden = true;
                                chart.data.datasets[j * 2 + 1].hidden = true;
                            }
                        }
                    }
                });
                updateOnSeekOrModeChange();
            };

            dataModeButton.addEventListener('click', () => {
                if (dataDisplayMode === 'filtered') dataDisplayMode = 'raw';
                else if (dataDisplayMode === 'raw') dataDisplayMode = 'compare';
                else dataDisplayMode = 'filtered';
                dataModeButton.textContent = `Mode: ${dataDisplayMode.charAt(0).toUpperCase() + dataDisplayMode.slice(1)}`;
                updateAllChartModes();
            });

             let dragCounter = 0;
            window.addEventListener('dragenter', (e) => { e.preventDefault(); e.stopPropagation(); dragCounter++; overlay.classList.remove('hidden'); });
            window.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); });
            window.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); dragCounter--; if (dragCounter === 0) overlay.classList.add('hidden'); });
            window.addEventListener('drop', (e) => {
                e.preventDefault(); e.stopPropagation(); dragCounter = 0; overlay.classList.add('hidden');
                const file = e.dataTransfer.files[0];
                if (file) {
                    if (file.name.toLowerCase().endsWith('.zip')) handleZipFile(file);
                    else if (file.name.toLowerCase().endsWith('.csv')) handleCsvFile(file);
                }
            });

             // Modal Logic
            document.querySelectorAll('.chart-wrapper').forEach(wrapper => {
                if (wrapper.querySelector('canvas')) { // Only add click to chart wrappers
                    wrapper.addEventListener('click', () => {
                        // if(isLiveMode) return; // Allow modal opening even in live mode

                        const canvasId = wrapper.querySelector('canvas').id;
                        const originalChart = charts[canvasId.replace('-chart', '')];
                        // Allow opening if file data exists OR live mode has started receiving data
                        if (originalChart && (telemetryData.length > 0 || (isLiveMode && liveDataCounter > 0))) { 
                            if (modalChartInstance) modalChartInstance.destroy();
                            
                            const modalOptions = JSON.parse(JSON.stringify(originalChart.options));
                            modalOptions.plugins.legend.display = true;
                            modalOptions.plugins.legend.position = 'bottom';
                            modalOptions.maintainAspectRatio = false;
                            modalOptions.plugins.title.display = false;
                            modalOptions.plugins.legend.labels = {
                                filter: function(legendItem, chartData) {
                                    const dataset = chartData.datasets[legendItem.datasetIndex];
                                    return !dataset.hidden;
                                }
                            };
                            modalTitle.textContent = originalChart.options.plugins.title.text;

                            // Build modal data based on current state (cropPoint, currentIndex OR live data)
                            const modalData = { labels: [], datasets: [] };
                            
                             let startIndex, endIndex;
                             let sourceLabels;
                             if (isLiveMode) {
                                 sourceLabels = originalChart.data.labels.slice(); // Copy live labels
                                 startIndex = 0; // Show all available live data in modal
                                 endIndex = sourceLabels.length;
                             } else {
                                 startIndex = cropPoint;
                                 endIndex = currentIndex + cropPoint;
                                 sourceLabels = Array.from({length: currentIndex}, (_, i) => i); // Generate relative labels
                             }

                            modalData.labels = sourceLabels;

                             originalChart.data.datasets.forEach((originalDs, dsIndex) => {
                                const isRaw = dsIndex % 2 !== 0;
                                const dataArray = isRaw ? telemetryData : filteredTelemetryData;
                                const dataKey = isRaw ? originalDs.label.replace('Raw ', '') : originalDs.label.replace('Filtered ', '');
                                
                                // Updated keyMap/multiKeyMap
                                const keyMap = { 'Altitude (m)': 'Altitude', 'Pressure (Pa)': 'Pressure', 'Velocity (m/s)': 'Velocity', 'Temperature (°C)': 'Temperature', 'Voltage (V)': 'Voltage'};
                                const multiKeyMap = { 
                                    Roll: { f: 'Gyro Roll', r: 'Gyro Roll' }, // Reverted: Plot rates
                                    Pitch: { f: 'Gyro Pitch', r: 'Gyro Pitch' }, // Reverted: Plot rates
                                    Yaw: { f: 'Gyro Yaw', r: 'Gyro Yaw' }, 
                                    AccX: { f: 'AccX', r: 'AccX' }, 
                                    AccY: { f: 'AccY', r: 'AccY' }, 
                                    AccZ: { f: 'AccZ', r: 'AccZ' }, 
                                    AutoGyro1: { f: 'Auto Rotation 1', r: 'Auto Rotation 1' }, 
                                    AutoGyro2: { f: 'Auto Rotation 2', r: 'Auto Rotation 2' }
                                };
                                let dataFieldName;
                                let sourceDataArray;

                                if (keyMap[dataKey]) {
                                    dataFieldName = keyMap[dataKey];
                                    sourceDataArray = dataArray;
                                } else if (multiKeyMap[dataKey]) {
                                    dataFieldName = isRaw ? multiKeyMap[dataKey].r : multiKeyMap[dataKey].f;
                                    sourceDataArray = isRaw ? telemetryData : filteredTelemetryData; // Raw data from telemetryData, Filtered from filteredTelemetryData
                                }


                                let slicedData;
                                 if (isLiveMode) {
                                    // In live mode, just copy the current data from the main chart
                                    slicedData = originalDs.data.slice(); 
                                } else {
                                     slicedData = sourceDataArray.slice(startIndex, endIndex).map(row => row ? row[dataFieldName] : null); // Add safety check for row
                                }
                                
                                modalData.datasets.push({
                                    ...originalDs, // Copy style properties
                                    data: slicedData,
                                    hidden: !originalChart.isDatasetVisible(dsIndex) // Maintain visibility
                                });
                            });

                            modalChartInstance = new Chart(modalCanvasCtx, { type: 'line', data: modalData, options: modalOptions });
                            modalChartInstance.originalChart = originalChart; 
                            chartModal.classList.remove('hidden');
                        }
                    });
                }
            });
            
            const closeModal = () => {
                chartModal.classList.add('hidden');
                if (modalChartInstance) { modalChartInstance.destroy(); modalChartInstance = null; }
            };

            modalCloseBtn.addEventListener('click', closeModal);
            chartModal.addEventListener('click', (e) => { if (e.target === chartModal) closeModal(); });
            
            window.addEventListener('keydown', (e) => { 
                if (e.target.tagName === 'INPUT') return;

                switch(e.key.toLowerCase()) { // Use toLowerCase for case-insensitivity
                    case 'escape':
                        if (!chartModal.classList.contains('hidden')) {
                            closeModal();
                        }
                        break;
                    case ' ':
                        e.preventDefault(); 
                        if (!playPauseBtn.disabled) togglePlayPause();
                        break;
                    case 'arrowright':
                        if (!forwardBtn.disabled) seek(5);
                        break;
                    case 'arrowleft':
                        if (!rewindBtn.disabled) seek(-5);
                        break;
                    case 'tab':
                        e.preventDefault();
                        if (!speedBtn.disabled) changeSpeed();
                        break;
                    case 'control':
                        e.preventDefault();
                        if (!endBtn.disabled) handleEndReplayClick();
                        break;
                    case '1':
                        if (!dataModeButton.disabled) {
                            dataDisplayMode = 'filtered';
                            dataModeButton.textContent = 'Mode: Filtered';
                            updateAllChartModes();
                        }
                        break;
                    case '2':
                         if (!dataModeButton.disabled) {
                            dataDisplayMode = 'raw';
                            dataModeButton.textContent = 'Mode: Raw';
                            updateAllChartModes();
                        }
                        break;
                    case '3':
                         if (!dataModeButton.disabled) {
                            dataDisplayMode = 'compare';
                            dataModeButton.textContent = 'Mode: Compare';
                            updateAllChartModes();
                        }
                        break;
                    case 'c': // Added shortcut for Crop
                         if (!cropBtn.disabled) cropData();
                         break;
                }
            });

            initCharts();
            setupChartToggles();
             updateButtonStates(); // Ensure buttons are correct on initial load
        });
    </script>
</body>
</html>
